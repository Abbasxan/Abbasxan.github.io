<!DOCTYPE html>
<html lang="az">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>≈ûahmat | Neon Sultan</title>
  <link rel="stylesheet" href="../assets/css/style.css" />
  <style>
    body {background: radial-gradient(circle at 60% 20%, #495082 0%, #181924 100%);}
    .chess-container {display:flex; flex-direction:column; align-items:center; margin-top:48px; background:rgba(24,25,36,.97); border-radius:18px; padding:36px 32px 32px 32px; box-shadow:0 10px 44px #000b; max-width:450px; margin:auto;}
    .chess-title { font-size:2em; color:#61dafb; margin-bottom:8px; text-shadow:0 2px 12px #222b;}
    .chess-mode-row { margin-bottom: 12px; display: flex; gap: 14px; }
    .chess-mode-btn { background:linear-gradient(90deg,#61dafb,#fbbd23); color:#222; border:none; border-radius:9px; font-weight:bold; font-size:1em; padding:7px 20px; cursor:pointer; box-shadow:0 2px 8px #0004; transition:.16s;}
    .chess-mode-btn.active, .chess-mode-btn:focus { background:linear-gradient(90deg,#fbbd23,#61dafb); color:#fff; outline:2px solid #fbbd23;}
    .chess-board {display:grid; grid-template-columns:repeat(8,40px); grid-template-rows:repeat(8,40px); gap:2px; margin-top:16px; margin-bottom:18px;}
    /* –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ü–≤–µ—Ç–∞ –¥–æ—Å–∫–∏ */
    .chess-cell {
      width:40px; height:40px; border-radius:7px;
      display:flex; align-items:center; justify-content:center;
      font-size:1.9em; cursor:pointer; transition:.15s;
      position: relative;
      box-shadow: 0 1.5px 5px #0003;
    }
    .chess-cell.dark {
      background: #2d3250;
      /* –≥–ª—É–±–æ–∫–∏–π —Å–∏–Ω–∏–π –¥–ª—è —Ç—ë–º–Ω—ã—Ö */
    }
    .chess-cell.light {
      background: #f3eecb;
      /* —Å–≤–µ—Ç–ª—ã–π –±–µ–∂–µ–≤—ã–π –¥–ª—è —Å–≤–µ—Ç–ª—ã—Ö */
    }
    /* –ö–æ–Ω—Ç—Ä–∞—Å—Ç–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã */
    .chess-piece-white {
      color: #f6f6f6;
      text-shadow: 0 0 2px #222, 0 2px 8px #fff8;
      filter: drop-shadow(0 0 10px #fff6);
    }
    .chess-piece-black {
      color: #222b3d;
      text-shadow: 0 0 2px #fff, 0 2px 8px #000a;
      filter: drop-shadow(0 0 8px #2228);
    }
    .chess-cell.selected {outline:2.5px solid #fbbd23;}
    .chess-cell.move {box-shadow:0 0 0 3px #00e67699;}
    .chess-status {color:#fff; font-size:1.12em; min-height:32px; margin-bottom:8px; text-shadow:0 2px 8px #2229;}
    .chess-btn {margin-top:13px; padding:10px 24px; font-size:1em; border-radius:9px; border:none; background:linear-gradient(90deg,#61dafb,#fbbd23); color:#222; font-weight:bold; cursor:pointer; box-shadow:0 2px 8px #0004; transition:background .2s, color .2s, transform .12s;}
    .chess-btn.secondary {background:#222; color:#fff; margin-top:10px;}
    .chess-btn:hover {background:linear-gradient(90deg,#fbbd23,#61dafb); color:#fff; transform:translateY(-2px) scale(1.07);}
    .chess-controls-mobile {
      display: none;
      margin-top: 10px;
      width: 100%;
      max-width: 350px;
      justify-content: center;
      gap: 8px;
    }
    .chess-controls-mobile button {
      background: #23233b;
      color: #fbbd23;
      font-size: 1.3em;
      border: none;
      border-radius: 11px;
      width: 44px; height: 44px;
      margin: 2px;
      box-shadow: 0 2px 10px #0007;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: manipulation;
      transition: background .13s, color .13s;
    }
    .chess-controls-mobile button:active, .chess-controls-mobile button.active { background: #fbbd23; color: #23233b; }
    .chess-fullscreen-btn {
      margin-top: 14px;
      padding: 10px 24px;
      font-size: 1.1em;
      border-radius: 10px;
      border: none;
      background: #181924;
      color: #61dafb;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 8px #222b44;
      transition: background .2s, color .2s;
      width: 100%;
      max-width: 340px;
    }
    .chess-fullscreen-btn:active, .chess-fullscreen-btn:focus {
      background: #61dafb;
      color: #181924;
      outline: 2px solid #ffd600;
    }
    @media (max-width:600px){
      .chess-container{padding:10px 2vw; max-width: 99vw;}
      .chess-board {grid-template-columns:repeat(8,10vw);grid-template-rows:repeat(8,10vw);}
      .chess-cell {font-size:5vw;width:10vw;height:10vw;}
      .chess-title {font-size:1.4em;}
      .chess-status {font-size:1em;}
      .chess-btn {font-size:0.98em;}
      .chess-controls-mobile{display:flex;}
    }
  </style>
</head>
<body>
  <nav class="navbar modern-navbar"><div class="container"><div class="logo">Neon Sultan</div></div></nav>
  <main class="chess-container" id="chessMain">
    <div class="chess-title">≈ûahmat (Chess)</div>
    <div class="chess-mode-row">
      <button id="modePVP" class="chess-mode-btn active" onclick="setChessMode('pvp')">2 n…ôf…ôr</button>
      <button id="modeAI" class="chess-mode-btn" onclick="setChessMode('ai')">NEON AI</button>
    </div>
    <div class="chess-status" id="chessStatus"></div>
    <div class="chess-board" id="chessBoard"></div>
    <div class="chess-controls-mobile" id="chessMobileControls">
      <button id="btnUndo" aria-label="Geri al (undo)">‚Ü©Ô∏è</button>
      <button id="btnFS" class="chess-fullscreen-btn" aria-label="Tam ekran rejimi">‚õ∂</button>
      <button id="btnFlip" aria-label="Taxtanƒ± √ßevirm…ôk">üîÑ</button>
    </div>
    <button class="chess-btn" onclick="chessReset()">Yenid…ôn ba≈üla</button>
    <a href="../oyunlar.html" class="chess-btn secondary">‚Üê Oyunlara qayƒ±t</a>
  </main>
  <footer class="footer"><p>¬© 2025 Sultan. Neon Group Azerbaijan</p></footer>
  <script>
    // --- State ---
    let chessMode = 'pvp', chessBoardArr, chessTurn, chessSelected, chessMoves, chessFinished=false, chessAIThinking=false;
    let chessHistory = [];
    let chessFlipped = false;
    const PIECES = {
      r: "‚ôú", n: "‚ôû", b:"‚ôù", q:"‚ôõ", k:"‚ôö", p:"‚ôü",
      R: "‚ôñ", N: "‚ôò", B:"‚ôó", Q:"‚ôï", K:"‚ôî", P:"‚ôô"
    };
    function setChessMode(nm){
      chessMode = nm;
      document.getElementById('modePVP').classList.toggle('active',chessMode==='pvp');
      document.getElementById('modeAI').classList.toggle('active',chessMode==='ai');
      chessReset();
    }
    function chessReset(){
      chessBoardArr = [
        ["r","n","b","q","k","b","n","r"],
        ["p","p","p","p","p","p","p","p"],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        ["P","P","P","P","P","P","P","P"],
        ["R","N","B","Q","K","B","N","R"],
      ];
      chessTurn = "w"; chessSelected=null; chessMoves=[]; chessFinished=false; chessAIThinking=false;
      chessHistory = [];
      chessFlipped = false;
      updateChessStatus(); chessRender();
      if(chessMode==='ai' && chessTurn==='b'){ setTimeout(chessAI, 350);}
    }
    function chessRender(){
      let brd = '';
      let legal = chessSelected?legalMoves(chessSelected.y,chessSelected.x):[];
      let rows = [...Array(8).keys()];
      if(chessFlipped) rows = rows.slice().reverse();
      for(let y of rows){
        let cols = [...Array(8).keys()];
        if(chessFlipped) cols = cols.slice().reverse();
        for(let x of cols){
          let dark = (x+y)%2;
          let s = `class="chess-cell ${dark?'dark':'light'}`;
          if(chessSelected&&chessSelected.x===x&&chessSelected.y===y)s+=" selected";
          if(legal.some(m=>m.x===x&&m.y===y))s+=" move";
          s+='"';
          brd += `<div ${s} onclick="chessCellClick(${y},${x})">`;
          let v = chessBoardArr[y][x];
          if(v) {
            let pieceClass = /^[A-Z]$/.test(v) ? 'chess-piece-white' : 'chess-piece-black';
            brd += `<span class="${pieceClass}">${PIECES[v]}</span>`;
          }
          brd += '</div>';
        }
      }
      document.getElementById('chessBoard').innerHTML = brd;
    }
    function updateChessStatus(){
      if(chessFinished){
        document.getElementById('chessStatus').textContent = (chessTurn==='w'?"Qara":"Aƒü")+" qalib oldu!";
        return;
      }
      if(chessMode==='ai') document.getElementById('chessStatus').textContent = chessTurn==='w' ? "S…ônin n√∂vb…ôn (aƒü)" : "NEON AI d√º≈ü√ºn√ºr...";
      else document.getElementById('chessStatus').textContent = (chessTurn==='w'?"Aƒü":"Qara")+" n√∂vb…ôd…ô";
    }
    function chessCellClick(y,x){
      if(chessFinished||chessAIThinking||(chessMode==='ai'&&chessTurn==='b'))return;
      let v = chessBoardArr[y][x];
      if(v&&(chessTurn==='w'?/^[A-Z]$/.test(v):/^[a-z]$/.test(v))){
        chessSelected={y,x};
        chessRender();
        return;
      }
      if(chessSelected){
        let moves = legalMoves(chessSelected.y,chessSelected.x);
        let found = moves.find(m=>m.x===x&&m.y===y);
        if(found){
          chessMove(chessSelected.y,chessSelected.x,found.y,found.x);
        }
      }
    }
    function legalMoves(y,x){
      let v = chessBoardArr[y][x];
      let moves = [], dirs, step, ny, nx, t;
      if(!v)return [];
      let color = /^[A-Z]$/.test(v)?"w":"b";
      if(v==="P"||v==="p"){
        let dir = v==="P"?-1:1, start = v==="P"?6:1;
        ny = y+dir;
        if(ny>=0&&ny<8&&!chessBoardArr[ny][x]) moves.push({y:ny,x:x});
        if((y===start)&&!chessBoardArr[y+dir][x]&&!chessBoardArr[y+2*dir][x]) moves.push({y:y+2*dir,x:x});
        for(let dx of [-1,1]){
          nx = x+dx;
          if(ny>=0&&ny<8&&nx>=0&&nx<8&&chessBoardArr[ny][nx]&&(/^[A-Z]$/.test(v)?/^[a-z]$/.test(chessBoardArr[ny][nx]):/^[A-Z]$/.test(chessBoardArr[ny][nx]))) moves.push({y:ny,x:nx});
        }
      }
      if(v.toLowerCase()==="n") for(let [dy,dx] of [[-2,-1],[-2,1],[2,-1],[2,1],[-1,-2],[-1,2],[1,-2],[1,2]]){
        ny=y+dy;nx=x+dx;
        if(ny>=0&&ny<8&&nx>=0&&nx<8&&(!chessBoardArr[ny][nx]||(color==="w"?/^[a-z]$/.test(chessBoardArr[ny][nx]):/^[A-Z]$/.test(chessBoardArr[ny][nx])))) moves.push({y:ny,x:nx});
      }
      let lines = [];
      if("RQrq".includes(v)) lines.push([1,0],[0,1],[-1,0],[0,-1]);
      if("BQbq".includes(v)) lines.push([1,1],[1,-1],[-1,1],[-1,-1]);
      for(let [dy,dx] of lines){
        ny = y+dy; nx = x+dx;
        while(ny>=0&&ny<8&&nx>=0&&nx<8){
          t=chessBoardArr[ny][nx];
          if(!t) moves.push({y:ny,x:nx});
          else{
            if(color==="w"?/^[a-z]$/.test(t):/^[A-Z]$/.test(t)) moves.push({y:ny,x:nx});
            break;
          }
          ny+=dy; nx+=dx;
        }
      }
      if("Kk".includes(v)){
        for(let dy of [-1,0,1])for(let dx of [-1,0,1]) if(dy||dx){
          ny=y+dy; nx=x+dx;
          if(ny>=0&&ny<8&&nx>=0&&nx<8&&( !chessBoardArr[ny][nx] || (color==="w"?/^[a-z]$/.test(chessBoardArr[ny][nx]):/^[A-Z]$/.test(chessBoardArr[ny][nx])) )) moves.push({y:ny,x:nx});
        }
      }
      return moves.filter(m=>!wouldBeInCheck(y,x,m.y,m.x,color));
    }
    function wouldBeInCheck(y1,x1,y2,x2,color){
      let backup = JSON.parse(JSON.stringify(chessBoardArr));
      let v = chessBoardArr[y1][x1];
      chessBoardArr[y1][x1]=null;
      chessBoardArr[y2][x2]=v;
      let kingPos = null, enemy = color==='w'?/^[a-z]$/:/^[A-Z]$/;
      for(let y=0;y<8;y++)for(let x=0;x<8;x++){
        if(chessBoardArr[y][x]===(color==='w'?'K':'k')) kingPos={y,x};
      }
      let inCheck = false;
      outer:for(let y=0;y<8;y++)for(let x=0;x<8;x++)if(chessBoardArr[y][x]&&enemy.test(chessBoardArr[y][x])){
        for(let m of legalMovesNoCheck(y,x)) if(m.y===kingPos.y&&m.x===kingPos.x){inCheck=true;break outer;}
      }
      chessBoardArr = backup;
      return inCheck;
    }
    function legalMovesNoCheck(y,x){
      let v = chessBoardArr[y][x];
      let moves = [], dirs, step, ny, nx, t;
      if(!v)return [];
      let color = /^[A-Z]$/.test(v)?"w":"b";
      if(v==="P"||v==="p"){
        let dir = v==="P"?-1:1, start = v==="P"?6:1;
        ny = y+dir;
        if(ny>=0&&ny<8&&!chessBoardArr[ny][x]) moves.push({y:ny,x:x});
        if((y===start)&&!chessBoardArr[y+dir][x]&&!chessBoardArr[y+2*dir][x]) moves.push({y:y+2*dir,x:x});
        for(let dx of [-1,1]){
          nx = x+dx;
          if(ny>=0&&ny<8&&nx>=0&&nx<8&&chessBoardArr[ny][nx]&&(/^[A-Z]$/.test(v)?/^[a-z]$/.test(chessBoardArr[ny][nx]):/^[A-Z]$/.test(chessBoardArr[ny][nx]))) moves.push({y:ny,x:nx});
        }
      }
      if(v.toLowerCase()==="n") for(let [dy,dx] of [[-2,-1],[-2,1],[2,-1],[2,1],[-1,-2],[-1,2],[1,-2],[1,2]]){
        ny=y+dy;nx=x+dx;
        if(ny>=0&&ny<8&&nx>=0&&nx<8&&(!chessBoardArr[ny][nx]||(color==="w"?/^[a-z]$/.test(chessBoardArr[ny][nx]):/^[A-Z]$/.test(chessBoardArr[ny][nx])))) moves.push({y:ny,x:nx});
      }
      let lines = [];
      if("RQrq".includes(v)) lines.push([1,0],[0,1],[-1,0],[0,-1]);
      if("BQbq".includes(v)) lines.push([1,1],[1,-1],[-1,1],[-1,-1]);
      for(let [dy,dx] of lines){
        ny = y+dy; nx = x+dx;
        while(ny>=0&&ny<8&&nx>=0&&nx<8){
          t=chessBoardArr[ny][nx];
          if(!t) moves.push({y:ny,x:nx});
          else{
            if(color==="w"?/^[a-z]$/.test(t):/^[A-Z]$/.test(t)) moves.push({y:ny,x:nx});
            break;
          }
          ny+=dy; nx+=dx;
        }
      }
      if("Kk".includes(v)){
        for(let dy of [-1,0,1])for(let dx of [-1,0,1]) if(dy||dx){
          ny=y+dy; nx=x+dx;
          if(ny>=0&&ny<8&&nx>=0&&nx<8&&( !chessBoardArr[ny][nx] || (color==="w"?/^[a-z]$/.test(chessBoardArr[ny][nx]):/^[A-Z]$/.test(chessBoardArr[ny][nx])) )) moves.push({y:ny,x:nx});
        }
      }
      return moves;
    }
    function chessMove(y1,x1,y2,x2){
      chessHistory.push({
        board: chessBoardArr.map(row=>row.slice()),
        turn: chessTurn,
        finished: chessFinished
      });
      let v=chessBoardArr[y1][x1];
      if((v==="P"&&y2===0)||(v==="p"&&y2===7)) v = v==="P"?"Q":"q";
      chessBoardArr[y1][x1]=null;
      chessBoardArr[y2][x2]=v;
      chessSelected=null;
      let kings = [].concat(...chessBoardArr).filter(p=>p==="K"||p==="k");
      if(kings.length<2){chessFinished=true;}
      else if(!hasAnyLegalMoves(chessTurn==="w"?"b":"w")){chessFinished=true;}
      chessTurn = chessTurn==="w"?"b":"w";
      updateChessStatus(); chessRender();
      if(chessMode==='ai' && chessTurn==='b' && !chessFinished){setTimeout(chessAI, 550);}
    }
    function hasAnyLegalMoves(color){
      for(let y=0;y<8;y++)for(let x=0;x<8;x++)
        if(chessBoardArr[y][x]&&((color==="w"&&/^[A-Z]$/.test(chessBoardArr[y][x]))||(color==="b"&&/^[a-z]$/.test(chessBoardArr[y][x]))))
          if(legalMoves(y,x).length) return true;
      return false;
    }
    function chessAI(){
      chessAIThinking=true;updateChessStatus();
      setTimeout(()=>{
        let movesList=[];
        for(let y=0;y<8;y++)for(let x=0;x<8;x++)
          if(chessBoardArr[y][x]&&/^[a-z]$/.test(chessBoardArr[y][x])){
            let legal = legalMoves(y,x);
            for(let m of legal)
              movesList.push({
                from:{y,x},
                to:{y:m.y,x:m.x},
                capture: chessBoardArr[m.y][m.x] ? pieceValue(chessBoardArr[m.y][m.x]) : 0,
                self: pieceValue(chessBoardArr[y][x])
              });
          }
        let captureMoves = movesList.filter(m=>m.capture>0);
        let pick;
        if(captureMoves.length) {
          captureMoves.sort((a,b)=>b.capture-a.capture);
          pick = captureMoves[0];
        } else {
          let safeMoves = movesList.filter(m=>{
            let backup = chessBoardArr.map(row=>row.slice());
            let v = chessBoardArr[m.from.y][m.from.x];
            let taken = chessBoardArr[m.to.y][m.to.x];
            chessBoardArr[m.from.y][m.from.x]=null;
            chessBoardArr[m.to.y][m.to.x]=v;
            let underAttack = false;
            for(let y2=0;y2<8;y2++)for(let x2=0;x2<8;x2++)
              if(chessBoardArr[y2][x2]&&/^[A-Z]$/.test(chessBoardArr[y2][x2])){
                let legal2 = legalMoves(y2,x2);
                if(legal2.some(mm=>mm.y===m.to.y&&mm.x===m.to.x)) underAttack=true;
              }
            chessBoardArr = backup;
            return !underAttack || m.self<=3;
          });
          pick = safeMoves.length ? safeMoves[Math.floor(Math.random()*safeMoves.length)] : movesList[Math.floor(Math.random()*movesList.length)];
        }
        if(pick)chessMove(pick.from.y,pick.from.x,pick.to.y,pick.to.x);
        chessAIThinking=false;
      },700+Math.random()*400);
    }
    function pieceValue(p) {
      if(!p) return 0;
      if("pP".includes(p)) return 1;
      if("nNbB".includes(p)) return 3;
      if("rR".includes(p)) return 5;
      if("qQ".includes(p)) return 9;
      if("kK".includes(p)) return 100;
    }
    document.getElementById('btnUndo').onclick = function() {
      if(chessHistory.length) {
        let prev = chessHistory.pop();
        chessBoardArr = prev.board.map(row=>row.slice());
        chessTurn = prev.turn;
        chessFinished = prev.finished;
        chessSelected = null;
        updateChessStatus();
        chessRender();
      }
    };
    document.getElementById('btnFlip').onclick = function() {
      chessFlipped = !chessFlipped;
      chessRender();
    };
    document.getElementById('btnFS').onclick = function() {
      const el = document.getElementById('chessMain');
      if (!document.fullscreenElement && el.requestFullscreen) {
        el.requestFullscreen();
      } else if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    };
    document.addEventListener('fullscreenchange', () => {
      const btn = document.getElementById('btnFS');
      if(document.fullscreenElement){
        btn.textContent = '‚õ∂ √ßƒ±x';
        btn.setAttribute('aria-label','Tam ekrandan √ßƒ±x');
      } else {
        btn.textContent = '‚õ∂';
        btn.setAttribute('aria-label','Tam ekran rejimi');
      }
    });
    let dragFrom = null;
    document.getElementById('chessBoard').addEventListener('touchstart', function(e){
      let cell = e.target.closest('.chess-cell');
      if(!cell)return;
      let idx = Array.from(document.getElementById('chessBoard').children).indexOf(cell);
      let y = Math.floor(idx/8), x = idx%8;
      dragFrom = {y,x};
    });
    document.getElementById('chessBoard').addEventListener('touchend', function(e){
      if(dragFrom){
        let touch = e.changedTouches[0];
        let el = document.elementFromPoint(touch.clientX, touch.clientY);
        let cell = el.closest('.chess-cell');
        if(cell){
          let idx = Array.from(document.getElementById('chessBoard').children).indexOf(cell);
          let y2 = Math.floor(idx/8), x2 = idx%8;
          if(dragFrom.y!==y2||dragFrom.x!==x2)
            chessCellClick(dragFrom.y,dragFrom.x),chessCellClick(y2,x2);
        }
        dragFrom = null;
      }
    });
    let touchStartY = 0;
    document.getElementById('chessBoard').addEventListener('touchstart', function(e){
      if(e.touches.length===1) touchStartY = e.touches[0].clientY;
    });
    document.getElementById('chessBoard').addEventListener('touchend', function(e){
      if(e.changedTouches.length===1) {
        let dy = e.changedTouches[0].clientY - touchStartY;
        if(dy>40) document.getElementById('btnFS').click();
      }
    });
    chessReset();
  </script>
</body>
</html>
